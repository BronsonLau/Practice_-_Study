# 935. 骑士拨号器
# 中等

# 象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。
# 象棋骑士可能的移动方式如下图所示:
# 我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。

# 给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。
# 你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。

# 因为答案可能很大，所以输出答案模 109 + 7.

class practice241210(object):
    def knightDialer(self, N):
        MOD = 10**9 + 7
        moves = [[4,6],[6,8],[7,9],[4,8],[3,9,0],[],
                     [1,7,0],[2,6],[1,3],[2,4]]

        dp = [1] * 10
        for hops in xrange(N-1):
            dp2 = [0] * 10
            for node, count in enumerate(dp):
                for nei in moves[node]:
                    dp2[nei] += count
                    dp2[nei] %= MOD
            dp = dp2
        return sum(dp) % MOD
    
#思路：
#动态规划
#dp[i][j]表示第i步到达数字j的方案数
#dp[i][j] = sum(dp[i-1][k]) for k in moves[j]
#初始状态dp[0][j] = 1

#时间复杂度O(N)
#空间复杂度O(1)