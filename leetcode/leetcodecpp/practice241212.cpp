// 2931. 购买物品的最大开销
// 困难

// 给你一个下标从 0 开始大小为 m * n 的整数矩阵 values ，表示 m 个不同商店里 m * n 件不同的物品。每个商店有 n 件物品，第 i 个商店的第 j 件物品的价值为 values[i][j] 。除此以外，第 i 个商店的物品已经按照价值非递增排好序了，也就是说对于所有 0 <= j < n - 1 都有 values[i][j] >= values[i][j + 1] 。

// 每一天，你可以在一个商店里购买一件物品。具体来说，在第 d 天，你可以：

// 选择商店 i 。
// 购买数组中最右边的物品 j ，开销为 values[i][j] * d 。换句话说，选择该商店中还没购买过的物品中最大的下标 j ，并且花费 values[i][j] * d 去购买。
// 注意，所有物品都视为不同的物品。比方说如果你已经从商店 1 购买了物品 0 ，你还可以在别的商店里购买其他商店的物品 0 。

// 请你返回购买所有 m * n 件物品需要的 最大开销 。

 

// 示例 1：

// 输入：values = [[8,5,2],[6,4,1],[9,7,3]]
// 输出：285
// 解释：第一天，从商店 1 购买物品 2 ，开销为 values[1][2] * 1 = 1 。
// 第二天，从商店 0 购买物品 2 ，开销为 values[0][2] * 2 = 4 。
// 第三天，从商店 2 购买物品 2 ，开销为 values[2][2] * 3 = 9 。
// 第四天，从商店 1 购买物品 1 ，开销为 values[1][1] * 4 = 16 。
// 第五天，从商店 0 购买物品 1 ，开销为 values[0][1] * 5 = 25 。
// 第六天，从商店 1 购买物品 0 ，开销为 values[1][0] * 6 = 36 。
// 第七天，从商店 2 购买物品 1 ，开销为 values[2][1] * 7 = 49 。
// 第八天，从商店 0 购买物品 0 ，开销为 values[0][0] * 8 = 64 。
// 第九天，从商店 2 购买物品 0 ，开销为 values[2][0] * 9 = 81 。
// 所以总开销为 285 。
// 285 是购买所有 m * n 件物品的最大总开销。

class Solution {
public:
    long long maxSpending(vector<vector<int>>& values) {
        int m = values.size(), n = values[0].size();
        priority_queue<ti3, vector<ti3>, greater<ti3>> q;
        for (int i = 0; i < m; ++i) {
            q.emplace(values[i][n - 1], i, n - 1);
        }
        long long ans = 0;
        for (int turn = 1; turn <= m * n; ++turn) {
            auto [val, i, j] = q.top();
            q.pop();
            ans += static_cast<long long>(val) * turn;
            if (j > 0) {
                q.emplace(values[i][j - 1], i, j - 1);
            }
        }
        return ans;
    }

private:
    using ti3 = tuple<int, int, int>;
};

// 时间复杂度：O(mnlogm)。
// 空间复杂度：O(m)。

// 思路：贪心
// 排序不等式 + 小根堆
// 思路与算法

// 由于每一个商店的物品都已经按照价值单调递减排好序了，那么当我们选择某个商店购买物品时，都可以买到该商店中价值最低的物品。由于我们可以任意选择商店，这就说，我们总是可以买到当前所有物品中价值最低的那个。

// 在开销的计算公式中，物品的价值会乘上购买它的天数。根据排序不等式，在理想状态下我们应该将所有商品按照价值从低到高排序，分别在第 1 到 m×n 天去购买。根据上一段的结论，我们一定是可以达到这个理想状态的。

// 因此，我们可以将 m×n 个商品按照价值进行排序，就可以得到答案，但这样做的时间复杂度是 O(mnlog(mn))，没有进一步用到「每一个商店的物品都已经按照价值单调递减排好序」这个性质。我们可以使用「23. 合并 K 个升序链表」中的方法，使用一个小根堆，存储每个商店当前价值最小的物品，那么小根堆的堆顶就是全局价值最小的物品。随后，我们将该物品在对应的商店中的下一个物品放入小根堆中，重复一共 m×n 次操作即可，时间复杂度降低至 O(mnlogm)。

