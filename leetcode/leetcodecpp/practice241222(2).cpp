// 1387. 将整数按权重排序
// 中等

// 我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：

// 如果 x 是偶数，那么 x = x / 2
// 如果 x 是奇数，那么 x = 3 * x + 1
// 比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）。

// 给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。

// 请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。

// 注意，题目保证对于任意整数 x （lo <= x <= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。

class Solution {
public:
    unordered_map <int, int> f;

    int getF(int x) {
        if (f.find(x) != f.end()) return f[x];
        if (x == 1) return f[x] = 0;
        if (x & 1) return f[x] = getF(x * 3 + 1) + 1;
        else return f[x] = getF(x / 2) + 1;
    }

    int getKth(int lo, int hi, int k) {
        vector <int> v;
        for (int i = lo; i <= hi; ++i) v.push_back(i);
        sort(v.begin(), v.end(), [&] (int u, int v) {
            if (getF(u) != getF(v)) return getF(u) < getF(v);
            else return u < v;
        });
        return v[k - 1];
    }
};



// 方法二：记忆化
// 思路

// 我们知道在求 f(3) 的时候会调用到 f(10)，在求 f(20) 的时候也会调用到 f(10)。同样的，如果单纯递归计算权重的话，会存在很多重复计算，我们可以用记忆化的方式来加速这个过程，即「先查表，再计算」和「先记忆，再返回」。我们可以用一个哈希映射作为这里的记忆化的「表」，这样保证每个元素的权值只被计算 1 次。在 [1,1000] 中所有 x 求 f(x) 的值的过程中，只可能出现 2228 种 x，于是效率就会大大提高。



// 复杂度分析

// 时间复杂度：平均情况下比较的次数为 nlogn，把 2228 次平摊到每一次的时间代价为 O( 
// nlogn
// 2228
// ​
//  )，故总时间代价为 O( 
// nlogn
// 2228
// ​
//  ×nlogn)=O(2228)。

// 空间复杂度：我们使用了长度为 n 的数组辅助进行排序，哈希映射只可能存在 2228 种键，故渐进空间复杂度为 O(n+2228)。由于这里我们使用了记忆化，因此递归使用的栈空间层数会均摊到所有的 n 中，由于 n 的最大值为 1000，因此每一个 n 使用的栈空间为 O( 
// 1000
// 2228
// ​
//  )≈O(2)，相较于排序的哈希映射需要的空间可以忽略不计。
