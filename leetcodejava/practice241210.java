// 935. 骑士拨号器
// 已解答
// 中等
// 相关标签
// 相关企业
// 象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。

// 象棋骑士可能的移动方式如下图所示:



// 我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。



// 给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。

// 你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。

// 因为答案可能很大，所以输出答案模 109 + 7.

class Solution {
    public int knightDialer(int N) {
        int MOD = 1_000_000_007;
        int[][] moves = new int[][]{
            {4,6},{6,8},{7,9},{4,8},{3,9,0},
            {},{1,7,0},{2,6},{1,3},{2,4}};

        int[][] dp = new int[2][10];
        Arrays.fill(dp[0], 1);
        for (int hops = 0; hops < N-1; ++hops) {
            Arrays.fill(dp[~hops & 1], 0);
            for (int node = 0; node < 10; ++node)
                for (int nei: moves[node]) {
                    dp[~hops & 1][nei] += dp[hops & 1][node];
                    dp[~hops & 1][nei] %= MOD;
                }
        }

        long ans = 0;
        for (int x: dp[~N & 1])
            ans += x;
        return (int) (ans % MOD);
    }
}



// 思路：
// 1. 用dp[i]表示骑士在第i个数字上的拨号次数
// 2. 用moves表示骑士在第i个数字上可以跳到的数字
// 3. 用dp2表示骑士在第i个数字上的拨号次数
// 4. 用dp2[nei] += count表示骑士在第i个数字上的拨号次数
// 5. 用sum(dp) % MOD表示骑士在第i个数字上的拨号次数

// 时间复杂度：O(N)
// 空间复杂度：O(1)