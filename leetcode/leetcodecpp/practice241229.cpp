// 1366. 通过投票对团队排名
// 中等

// 现在有一个特殊的排名系统，依据参赛团队在投票人心中的次序进行排名，每个投票者都需要按从高到低的顺序对参与排名的所有团队进行排位。

// 排名规则如下：

// 参赛团队的排名次序依照其所获「排位第一」的票的多少决定。如果存在多个团队并列的情况，将继续考虑其「排位第二」的票的数量。以此类推，直到不再存在并列的情况。
// 如果在考虑完所有投票情况后仍然出现并列现象，则根据团队字母的字母顺序进行排名。
// 给你一个字符串数组 votes 代表全体投票者给出的排位情况，请你根据上述排名规则对所有参赛团队进行排名。

// 请你返回能表示按排名系统 排序后 的所有团队排名的字符串。

class Solution {
public:
    string rankTeams(vector<string>& votes) {
        int n = votes.size();
        // 初始化哈希映射
        unordered_map<char, vector<int>> ranking;
        for (char vid: votes[0]) {
            ranking[vid].resize(votes[0].size());
        }
        // 遍历统计
        for (const string& vote: votes) {
            for (int i = 0; i < vote.size(); ++i) {
                ++ranking[vote[i]][i];
            }
        }
        
        // 取出所有的键值对
        using PCV = pair<char, vector<int>>;
        vector<PCV> result(ranking.begin(), ranking.end());
        // 排序
        sort(result.begin(), result.end(), [](const PCV& l, const PCV& r) {
            return l.second > r.second || (l.second == r.second && l.first < r.first);
        });
        string ans;
        for (auto& [vid, rank]: result) {
            ans += vid;
        }
        return ans;
    }
};

// 方法一：排序
// 设参与排名的人数为 n（即数组 votes 中任一字符串的长度），我们可以用一个哈希映射（HashMap）存储每一个人的排名情况。对于哈希映射中的每个键值对，键为一个在数组 votes 中出现的大写英文字母，表示一个参与排名的人；值为一个长度为 n 的数组 rank，表示这个人的排名情况，其中 rank[i] 表示这个人排名为 i 的次数。

// 我们遍历数组 votes 中的每一个字符串并进行统计，就可以得到上述存储了每一个人排名情况的哈希映射。随后我们将这些键值对取出，并放入数组中进行排序。记每一个键值对为 (vid,rank)，根据题目要求，我们需要以 rank 为第一关键字进行降序排序。在大部分语言中，我们是可以对变长的数组（例如 C++ 中的 vector，Python 中的 list）直接进行比较排序的，比较的方式是从首部的元素开始，依次比较两个数组同一位置的元素的大小，若相等则继续比较下一位置，直至数组的尾部（此时长度较长的数组较大，若长度相同，则这两个数组同样大）。因此第一关键字可以直接进行比较。在 rank 相等的情况下，我们需要以 vid 为第二关键字进行升序排序。在 C++ 中，我们可以自定义比较函数，完成多关键字的排序，而在 Python 中进行多关键字排序时，不同关键字的排序方式必须保持一致。我们可以将 vid 从字符转换为对应的 ASCII 码，并用其相反数作为第二关键字，这样就与第一关键字保持一致，即都进行降序排序。

// 在排序完成后，我们将每一个键值对中的键 vid 依次加入到答案字符串 ans 中，即可得到最终的答案。

// 复杂度分析
// 时间复杂度：O(NK+N 
// 2
//  logN)，其中 N 是数组 votes 中每一个字符串的长度（参与排名的人数），K 是数组 votes 的长度（参与投票的人数）。「遍历统计」的时间复杂度为 O(NK)，「排序」的时间复杂度为 O(N 
// 2
//  logN)（其中 O(NlogN) 为排序本身的时间，还需要额外的比较两个键值对大小的 O(N) 时间），建立最终答案字符串的时间复杂度为 O(N)，因此总时间复杂度为 O(NK+N 
// 2
//  logN)。

// 空间复杂度：O(N 
// 2
//  )。哈希映射中键值对的数量为 N，每个键使用 O(1) 的空间，每个值使用 O(N) 的空间，空间复杂度为 O(N 
// 2
//  )。存储排序的结果同样需要使用 O(N 
// 2
//  ) 的空间，因此总空间复杂度为 O(N 
// 2
//  )。

