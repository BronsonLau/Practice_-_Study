// 78. 子集

// 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的
// 子集（幂集）。

// 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

class Solution {
public:
    vector<int> t;
    vector<vector<int>> ans;

    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        for (int mask = 0; mask < (1 << n); ++mask) {
            t.clear();
            for (int i = 0; i < n; ++i) {
                if (mask & (1 << i)) {
                    t.push_back(nums[i]);
                }
            }
            ans.push_back(t);
        }
        return ans;
    }
};

// 方法一：迭代法实现子集枚举
// 思路与算法

// 记原序列中元素的总数为 n。原序列中的每个数字 a 
// i
// ​
//   的状态可能有两种，即「在子集中」和「不在子集中」。我们用 1 表示「在子集中」，0 表示不在子集中，那么每一个子集可以对应一个长度为 n 的 0/1 序列，第 i 位表示 a 
// i
// ​
//   是否在子集中。例如，n=3 ，a={5,2,9} 时：

// 0/1 序列	子集	0/1 序列对应的二进制数
// 000	{}	0
// 001	{9}	1
// 010	{2}	2
// 011	{2,9}	3
// 100	{5}	4
// 101	{5,9}	5
// 110	{5,2}	6
// 111	{5,2,9}	7
// 可以发现 0/1 序列对应的二进制数正好从 0 到 2 
// n
//  −1。我们可以枚举 mask∈[0,2 
// n
//  −1]，mask 的二进制表示是一个 0/1 序列，我们可以按照这个 0/1 序列在原集合当中取数。当我们枚举完所有 2 
// n
//   个 mask，我们也就能构造出所有的子集。

// 复杂度分析
// 时间复杂度：O(n×2^n)。一共 2^n个状态，每种状态需要 O(n) 的时间来构造子集。
// 空间复杂度：O(n)。即构造子集使用的临时数组 t 的空间代价。

