// 1387. 将整数按权重排序
// 中等

// 我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：

// 如果 x 是偶数，那么 x = x / 2
// 如果 x 是奇数，那么 x = 3 * x + 1
// 比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）。

// 给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。

// 请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。

// 注意，题目保证对于任意整数 x （lo <= x <= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。

class Solution {
public:
    int getF(int x) {
        if (x == 1) return 0;
        if (x & 1) return getF(x * 3 + 1) + 1;
        else return getF(x / 2) + 1;
    }

    int getKth(int lo, int hi, int k) {
        vector <int> v;
        for (int i = lo; i <= hi; ++i) v.push_back(i);
        sort(v.begin(), v.end(), [&] (int u, int v) {
            if (getF(u) != getF(v)) return getF(u) < getF(v);
            else return u < v;
        });
        return v[k - 1];
    }
};



// 方法一：递归
// 思路

// 记 x 的权重为 f(x)，按照题意很明显我们可以构造这样的递归式：

// f(x)= 
// ⎩
// ⎨
// ⎧
// ​
  
// 0
// f(3x+1)+1
// f( 
// 2
// x
// ​
//  )+1
// ​
  
// ,
// ,
// ,
// ​
  
// x=1
// xmod2=1
// xmod2=0
// ​
 
// 于是我们就可以递归求解每个数字的权重了。

// 复杂度分析

// 记区间长度为 n，等于 hi - lo + 1。

// 时间复杂度：这里的区间一定是 [1,1000] 的子集，在 [1,1000] 中权重最大数的权重为 178，即这个递归函数要执行 178 次，所以排序的每次比较的时间代价为 O(178)，故渐进时间复杂度为 O(178×nlogn)。

// 空间复杂度：我们使用了长度为 n 的数组辅助进行排序，同时再使用递归计算权重时最多会使用 178 层的栈空间，故渐进空间复杂度为 O(n+178)。

