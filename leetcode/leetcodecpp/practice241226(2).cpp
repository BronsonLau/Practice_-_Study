// 3083. 字符串及其反转中是否存在同一子字符串
// 简单

// 给你一个字符串 s ，请你判断字符串 s 是否存在一个长度为 2 的子字符串，在其反转后的字符串中也出现。

// 如果存在这样的子字符串，返回 true；如果不存在，返回 false 。

class Solution {
public:
    bool isSubstringPresent(string s) {
        vector<int> h(26);
        for (int i = 0; i + 1 < s.size(); i++) {
            int x = s[i] - 'a';
            int y = s[i + 1] - 'a';
            h[x] |= 1 << y;
            if (h[y] >> x & 1) {
                return true;
            }
        }
        return false;
    }
};

// 方法二：哈希表 + 位运算优化
// 思路与算法:
// 我们可以用哈希表提前存储字符串中的每个长度为 2 的子串，这样在判断翻转后的字符串是否出现时就避免了花费 O(n) 的时间查找。
// 由于字符仅包含小写字母，该哈希表可以用一个整数类型的二维数组实现，形如 hash[26][26]。如果要进一步优化，还可以考虑将第二维使用二进制表示，例如 hash[2] 二进制形式中，如果从低到高第 1 位为 1，则表示子串 ‘‘cb" 出现在字符串中（2 表示字符 c，1 表示字符 b）。


// 时间复杂度：O(n+C)，其中 n 是字符串的长度，C 为字符集大小，本题中等于 26。
// 空间复杂度：O(C)。