// 1963. 使字符串平衡的最小交换次数

// 给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 '[' 和 n / 2 个闭括号 ']' 组成。

// 只有能满足下述所有条件的字符串才能称为 平衡字符串 ：
// 字符串是一个空字符串，或者
// 字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者
// 字符串可以写成 [C] ，其中 C 是一个 平衡字符串 。
// 你可以交换 任意 两个下标所对应的括号 任意 次数。

// 返回使 s 变成 平衡字符串 所需要的 最小 交换次数。

class Solution {
    public:
        int minSwaps(string s) {
            int cnt = 0, mincnt = 0;
            for (char ch: s) {
                if (ch == '[') {
                    cnt += 1;
                }
                if (cnt > 0 && ch == ']'){
                    cnt --;
                }
            }
            return (cnt + 1) / 2;
        }
    };
    
// 实际上只要处理 形如 "]"*n+"["*n 这种类型的字符串就好,通过线性关系很容易知道答案 (n+1)/2 , 那算法就变成了用栈处理匹配然后计算n了


// 时间复杂度：O(n)，其中 n 是字符串 s 的长度。我们只需要遍历字符串 s 一次。
// 空间复杂度：O(n)，其中 n 是字符串 s 的长度。栈的深度不会超过字符串 s 的长度。